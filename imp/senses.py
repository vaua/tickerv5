import random
import copy


class Sense():

    '''This function returns a low and high value between which trigger is valid'''
    def get_valid_trigger_range(self):
        pass

    '''This function is called every time environment state should be translated into what specific sense on entity sees'''
    def get_trigger_value(self, entity, population):
        pass

    def get_random_trigger(self):
        pass

    def mutate_dna(self, dna, mutation_rate):
        
        for gene in dna:
            if len(gene) < 2:
                print("Found a strange gene: ", gene, " in dna: ", dna)
                exit()
                                
            if (random.randint(0, 99) < mutation_rate):
                gene[0] += 1
                if gene[0] == self.trigger_range[1]:
                    gene[0] = self.trigger_range[0]
            if (random.randint(0, 99) < mutation_rate):
                gene[1] += 1
                if gene[1] == self.actuator_range[1]:
                    gene[1] = self.actuator_range[0]
        return dna

    def get_random_sense_dna(self):

        dna = []

        ## A DNA from a sense consists of a number of valid triggers, along with 
        amount_of_genes_to_create = random.randrange(self.max_number_of_genes_to_random_contribution)

        for gene in range(amount_of_genes_to_create):
            # Create a random trigger and random action pair
            trigger = random.randrange(self.trigger_range[0], self.trigger_range[1])
            action = random.randrange(self.actuator_range[0], self.actuator_range[1])
            dna.append([trigger, action])

        return dna

    # Check if the trigger, as generated by the world, will produce some action.
    def get_sense_response_to_trigger(self, trigger, dna):
        triggered_actions = []
        chosen_actions = []

        #print("Trigger: ", trigger, " dna: ", dna)

        for gene in dna:
            if (len(gene) < 2):
                #print("Gene shorter than two!", gene)
                #print("DNA: ", dna)
                #print("Sense: ", self.id)
                continue

            if trigger == gene[0]:
                ## Trigger matched!
                triggered_actions.append(gene[1])

        if triggered_actions == []:
            return []
        else:
            chosen_actions.append(max(set(triggered_actions), key = triggered_actions.count))
            if len(chosen_actions) > 1:
                print("Chosen actions are many: ", chosen_actions)
            return chosen_actions







class OneDVisionNoOrientationOnePixelRange(Sense):

    def __init__(self, id):

        ## Constants
        self.id = id
        self.cost_of_move = 1
        self.cost_of_eating = 3
        self.benefit_of_eating = 20
        self.hurt_of_eating = 25
 


        ## Trigger input consist of three bits - each bit indicates entity present left, center, right
        self.trigger_range = [0, 8]

        ## Output consists of four possible actions: go left, stay, eat, go right  ["red", "blue", "orange", "green"]
        self.actuator_range = [0, 4]

        self.max_number_of_genes_to_random_contribution = 10

    def get_trigger_value(self, entity, concept):
        
        ## This trigger will return a 3 bit value, based on population
        ## Leftmost bit: 1 if something to the left (in the range positions)
        ## Middle bit. 1 if something in the same position as I
        ## Right bit - if something is in the range on the right

        
        trigger = 0
        ## Check if anybody to the left

        if concept.entity_exist_to_left(entity):
            trigger += 4
        if concept.entity_exist_in_place(entity):
            trigger += 2
        if concept.entity_exist_to_right(entity):
            trigger += 1

        return trigger


    def execute_action(self, entity, actions, world):

        #print("entity", entity)
        #print("1d Executing Actions: ", actions)
        
        for action in actions:
            ## Now execute the action. And remeber: go left, stay, eat, go right
            ## 0 == left - set position to one to the left, take down energy.
            if action == 0:
                world.position.set_value(entity, world.position.get_left(entity))
                world.energy.add_value(entity, -self.cost_of_move)
            elif action == 1:
                ## Nothing - we're just chilling
                continue
            elif action == 2:
                ## We're going to eat. Now - let's check if there is somebody else in the same position
                #if entity[1] == [[[0, 0], [0, 0], [4, 0], [1, 3], [6, 2], [7, 2], [3, 2], [2, 2], [1, 3], [5, 0]]]:
                #    print("I'm pepe, at position ", entity[0][0], " with energy: ", entity[0][1], " aiming to eat.")
                # But first - as we're already eating - take the cost of eating
                world.energy.add_value(entity, -self.cost_of_eating) 


                for e in world.position.get_entities_in_position(world.position.get_value(entity)):
                    if e == entity: 
                        ## It is me...
                        continue
                    # OK, now we have found an animal who we can eat.
                    ## Raise energy for the eater, and lower for the eatee.
                    world.energy.add_value(entity, self.benefit_of_eating)
                    world.energy.add_value(e, -self.hurt_of_eating)

                    world.eaten_animals.append(e[1])
                    #print("I'm at position ", entity[0][0], " and I'm eating ", e[0][0], " with energy ", e[0][1])
                    if entity[1] == world.chosen_dna:
                        print("I'm pepe, at position ", entity[0][0], " having eaten, now energy is ", entity[0][1])
                    if e[1] == world.chosen_dna:
                        print("I'm pepe, at position ", entity[0][0], " being eaten!!!, now energy is ", e[0][1])

                    if (world.world.get_entity_id(entity) == world.extra_log_entity_id):
                        print("The extra logged entity ", world.extra_log_entity_id, " is eating.")
                    if (world.world.get_entity_id(e) == world.extra_log_entity_id):
                        print("The extra logged entity ", world.extra_log_entity_id, " is being eaten.")


            ## Goind right
            elif action == 3:
                world.position.set_value(entity, world.position.get_right(entity))
                world.energy.add_value(entity, -self.cost_of_move)
            else:
                print("Cardinal error - output outside of triger")


class InternalEnergy(Sense):

    def __init__(self, id):
        
        ## Constants
        self.id = id
        self.energy_ratio_given_to_offspring = 0.3
        self.cost_of_birth = 50
        self.minimal_energy_needed = 10
        
        ## Trigger input consist of three bits - 8 values. Each value is a span of energy (max / 8)
        self.trigger_range = [0, 8]

        ## Output consists of eight possible actions: six are nothing, two are give birth
        self.actuator_range = [0, 8]

        self.max_number_of_genes_to_random_contribution = 10

    def get_trigger_value(self, entity, concept):
        
        ## Trigger will just read current energy and give a value based on that

        entity_energy = concept.get_value(entity)
        trigger = int (entity_energy * self.trigger_range[1] / (concept.max_energy + 1))
        return trigger


    def execute_action(self, entity, actions, world):

        if (len(actions) > 1):
            print("Whoa, this entity has many actions: ", actions)
        
        #print("nrg Executing Actions: ", actions)
        for action in actions:
            #print("Action: ", action)

            if action > 5:
                ## We're giving birth!
                parent_energy = world.energy.get_value(entity)
                energy_to_offspring = int(parent_energy * self.energy_ratio_given_to_offspring)
                if (energy_to_offspring < self.minimal_energy_needed):
                    #print("Too little energy, no birth.")
                    continue

                dna = copy.deepcopy(entity[1])
                new_entity = world.create_entity(dna, True)
                world.energy.set_value(new_entity, energy_to_offspring)
                world.world.set_generation(new_entity, world.world.get_generation(entity) + 1)
                # No mutation for now
                world.entities_to_add.append(new_entity)

                world.energy.add_value(entity, -energy_to_offspring)
                world.energy.add_value(entity, -self.cost_of_birth)
                if (world.world.get_entity_id(entity) == world.extra_log_entity_id):
                    print("The extra logged entity ", world.extra_log_entity_id, " gave birth, ", energy_to_offspring, " given to baby.")
                
                #entity[0][world.ENERGY] = 0
                #if (entity == world.chosen_dna):
                    #print("The chosen one after spawning: ", entity)

                #print("New being created! Parent ", world.world.get_entity_id(entity), " energy before: ", parent_energy, ", after: ", world.energy.get_value(entity), " offspring: ", world.energy.get_value(new_entity))